options ls=72 nocenter;

/*This code from Advanced biostatistics demonstrates my ability to utilize macros effectively for sequential designs for futility and efficacy*/

/* Code from support.sas.com/companionsites by Alex Dmitrienko      */    

%macro EffDesign(fraction, effsize, power, alpha, rho, boundary, sizepower);
/*
Inputs:
 
FRACTION = Input data set that contains fractions of the total sample 
           size accrued at successive analyses

EFFSIZE  = True effect size
 
POWER    = Power

ALPHA    = One-sided Type I error probability

RHO      = Shape parameter of stopping boundary
           (0.5 if Pocock boundary and 0 if O'Brien-Fleming boundary)

BOUNDARY = Output data set that contains stopping probabilities at scheduled 
           looks

SIZEPOWER= Output data set that contains average sample number and power for 
           selected effect sizes

*/
proc iml;
    start DriftSearch(d) global(m,critvalue,stfract,inc,infinity);        
        upper=critvalue*stfract##&rho;
        adjustment=d*stfract;
        boundary=infinity//(upper-adjustment);                     
        call seq(p,boundary) eps=1e-8 tscale=inc; 
        diff=abs(1-&power-(p[2,]-p[1,])[m]);          
        return(diff);
    finish;
    use &fraction;
    read all var _all_ into fraction;    
    m=nrow(fraction);    
    fract=t(fraction);    
    stfract=fract/fract[1];   
    inc=j(1,m-1,0);
    do i=1 to m-1;
        inc[i]=(fract[i+1]-fract[i])/fract[1];
    end;        
    infinity=repeat(.m,1,m);
    upper=stfract##&rho;
    boundary=infinity//upper;    
    call seqscale(prob,critvalue,boundary,1-&alpha) eps=1e-8 tscale=inc; 
    upper=critvalue*stfract##&rho;
    boundary=infinity//upper;    
    stopz=critvalue*stfract##(&rho-0.5);    
    stopp=1-probnorm(stopz);
    call seq(prob0,boundary) eps=1e-8 tscale=inc; 
    nfixed=2*((probit(&power)+probit(1-&alpha))/&effsize)**2;    
    start=&effsize*sqrt(nfixed*fract[1]/2);
    tc=repeat(.,1,12);
    tc[1]=100;
    tc[3]=1e-5;
    call nlpdd(rc,drift,"DriftSearch",start) tc=tc;
    max=2*(drift/&effsize)*(drift/&effsize)/fract[1];
    upper=critvalue*stfract##&rho;    
    adjustment=drift*stfract;
    boundary=infinity//(upper-adjustment);                 
    call seq(prob1,boundary) eps=1e-8 tscale=inc;   
    &boundary=j(m,8,0);
    &boundary[,1]=t(1:m);
    &boundary[,2]=ceil((fraction)*max);
    &boundary[,3]=t(stopz);
    &boundary[,4]=t(stopp);
    &boundary[,5]=t(prob0[3,]-prob0[2,]+prob0[1,]); 
    &boundary[,6]=t(cusum(prob0[3,]-prob0[2,]+prob0[1,]));     
    &boundary[,7]=t(prob1[3,]-prob1[2,]+prob1[1,]); 
    &boundary[,8]=t(cusum(prob1[3,]-prob1[2,]+prob1[1,]));             
    varnames={"Analysis", "Size", "TestStBoundary", "PValBoundary", "ProbH0", 
        "CumProbH0", "ProbH1", "CumProbH1"};    
    create &boundary from &boundary[colname=varnames];
    append from &boundary;    
    &sizepower=j(21,3,0);
    do i=0 to 20;
        upper=critvalue*stfract##&rho;
        adjustment=i*&effsize*sqrt(max*fract[1]/2)*stfract/10;
        boundary=infinity//(upper-adjustment);                     
        call seq(prob2,boundary) eps=1e-8 tscale=inc; 
        stop=prob2[3,]-prob2[2,]+prob2[1,]; 
        &sizepower[i+1,1]=i*&effsize/10;
        &sizepower[i+1,2]=ceil(max*(1-(1-fract)*stop`));   
        &sizepower[i+1,3]=1-(prob2[2,]-prob2[1,])[m]; 
    end;
    varnames={"EffSize", "AveSize", "Power"};    
    create &sizepower from &sizepower[colname=varnames];
    append from &sizepower;        
    summary=j(1,4,0);
    summary[1]=ceil(max); summary[2]=&sizepower[1,2]; 
    summary[3]=&sizepower[11,2];    
    summary[4]=ceil(nfixed);
    create summary from summary;
    append from summary;        
    quit; 
data summary;
    set summary;
    format value best6.;
    length par $50;
    par="One-sided Type I error probability"; 
        value=&alpha; output;    
    par="Power"; value=&power; output;
    par="True effect size"; value=&effsize; output;
    par="Stopping boundary parameter"; value=&rho; output;
    par="Maximum sample size per group"; value=col1; output;
    par="Average sample size per group under H0"; value=col2; output;
    par="Average sample size per group under H1"; value=col3; output;
    par="Fixed sample size per group"; value=col4; output;
    label par="Summary" value="Value";
    keep par value;
proc print data=summary noobs label;
    var par value;
data &boundary;
    set &boundary;
    format TestStBoundary PValBoundary ProbH0 CumProbH0 ProbH1 CumProbH1 6.4
        Analysis Size 4.0;
    label Analysis="Analysis"
          Size="Sample size per group"
          TestStBoundary="Stopping boundary (test statistic scale)"
          PValBoundary="Stopping boundary (p-value scale)"
          ProbH0="Stopping probability under H0"
          CumProbH0="Cumulative stopping probability under H0"
          ProbH1="Stopping probability under H1"
          CumProbH1="Cumulative stopping probability under H1";
data &sizepower;
    set &sizepower;
    format EffSize best6. AveSize 5.0;
    label EffSize="True effect size"
          AveSize="Average sample size per group"
          Power="Power";
    run;
%mend EffDesign;



/* Group Sequential Design using O'Brien-Fleming Boundary  */       

data DepTrial;
    input fraction @@;
    datalines;
    .15 .3 .5 .85 1
    ;
%EffDesign(fraction=DepTrial,effsize=0.375,power=0.9,alpha=0.025,
    rho=0,boundary=OFBoundary,sizepower=OFPower);
proc print data=OFBoundary noobs label;
    var Analysis Size TestStBoundary PValBoundary;
proc print data=OFBoundary noobs label;
    var Analysis ProbH0 CumProbH0 ProbH1 CumProbH1;

/* Group Sequential Design Using Pocock Boundary         */       

data DepTrial;
    input fraction @@;
    datalines;
    .15 .3 .5 .85 1
    ;
%EffDesign(fraction=DepTrial,effsize=0.375,power=0.9,alpha=0.025,
    rho=0.5,boundary=PBoundary,sizepower=PPower);
proc print data=PBoundary noobs label;
    var Analysis Size TestStBoundary PValBoundary;
proc print data=PBoundary noobs label;
    var Analysis ProbH0 CumProbH0 ProbH1 CumProbH1;
* Compare with the O'Brien-Fleming sequential plan;
%EffDesign(fraction=DepTrial,effsize=0.375,power=0.9,alpha=0.025,
    rho=0,boundary=OFBoundary,sizepower=OFPower);
data plot1;
    set OFBoundary; group=1;
data plot2;
    set PBoundary; group=2;
data plot3;
    set plot1 plot2;
    format TestStBoundary 1.0 PValBoundary 4.2;
* Stopping boundaries on a test statistic scale;
axis1 minor=none label=(angle=90 "Test statistic") order=(1 to 3 by 1);
axis2 minor=none label=("Sample size per group") order=(0 to 200 by 50);
symbol1 value=dot color=black i=join line=1;
symbol2 value=dot color=black i=join line=20;
proc gplot data=plot3;
    plot TestStBoundary*Size=group/frame haxis=axis2 vaxis=axis1 nolegend;
    run;
	quit;
* Stopping boundaries on a p-value scale;
axis1 minor=none label=(angle=90 "P-value") order=(0.0000 to 0.0300 by 0.0100);
axis2 minor=none label=("Sample size per group") order=(0 to 200 by 50);
symbol1 value=dot color=black i=join line=1;
symbol2 value=dot color=black i=join line=20;
proc gplot data=plot3;
    plot PValBoundary*Size=group/frame haxis=axis2 vaxis=axis1 nolegend;
	run; 
	quit;
data plot1;
    set OFPower; group=1;
data plot2;
    set PPower; group=2;
data plot3;
    set plot1 plot2;
    format Power 3.1 AveSize 4.0;
    run;
* Power functions;
axis1 minor=none label=(angle=90 "Power") order=(0 to 1 by 0.2);
axis2 minor=none label=("True effect size") order=(0 to 0.6 by 0.1);
symbol1 value=none color=black i=join line=1;
symbol2 value=none color=black i=join line=20;
proc gplot data=plot3;
    plot Power*EffSize=group/frame haxis=axis2 vaxis=axis1 nolegend;
    run;
	quit;
* Average sample size;
axis1 minor=none label=(angle=90 "Average sample size per group") 
    order=(0 to 200 by 50);
axis2 minor=none label=("True effect size") order=(0 to 0.6 by 0.1);
symbol1 value=none color=black i=join line=1;
symbol2 value=none color=black i=join line=20;
proc gplot data=plot3;
    plot AveSize*EffSize=group/frame haxis=axis2 vaxis=axis1 nolegend;
    run;
	quit;

*Prob 6 - Consider a clinical trial where stopping for futility occurs when the
conditional power crosses the boundary cL information fraction τ. For the hypothesis H0 : θI = 0
versus HA : θI = 3, graph the probability of early stopping (PL) against bL for τ = 0.5
and τ = 0.7 under H0 and HA; 
data one;
 powerd=0.85; *study powered at 85%;
 alphad=0.05; *two-sided alpha=0.05;
 zd=probit(1-alphad/2);
 thetad=probit(powerd)+probit(1-alphad/2); *design theta;
 thetai=thetad;
 tau=0.5; *information fraction t;
 cl=0.2; *stop trial if CP <= cl;
 *Boundaries on the B-value;
 bld=probit(cl)*sqrt(1-tau)-thetad*(1-tau)+zd; *design trend;
 bln=probit(cl)*sqrt(1-tau)+zd; *null trend;
 blt=bln*tau; *current trend;
 *Probabilities of early stopping under the 3 trends;
 pld=probnorm((bld-tau*thetai)/sqrt(tau));
 pln=probnorm((bln-tau*thetai)/sqrt(tau));
 plt=probnorm((blt-tau*thetai)/sqrt(tau));
proc print;
 var bld bln blt pld pln plt;
run;
data two;
 set one;
 *Compute mean and variance of U_t;
 muu=thetad*(1-tau);
 varu=1-tau;
 *Compute mean and variance of B_t;
 mub=tau*thetai;
 varb=tau;
 *Compute P(Type II error) using Monte Carlo integration;
 do j=1 to 100000;
 b=mub+sqrt(varb)*rannor(77653);  *generates a random variable from f;
 if b le bld then beta2d=0;  *Integral is 0 if b<b_L, otherwise estimate by the difference in the integral limits;
 *theta_I=theta_D;
 else beta2d=probnorm((1.96-muu-b)/sqrt(varu))-probnorm((-1.96-muu-b)/sqrt(varu));
 *theta_I=theta hat;
 if b le blt then beta2t=0;
 else beta2t=probnorm((1.96-muu-b)/sqrt(varu))-probnorm((-1.96-muu-b)/sqrt(varu));
 *theta_I=0;
 if b le bln then beta2n=0;
 else beta2n=probnorm((1.96-muu-b)/sqrt(varu))-probnorm((-1.96-muu-b)/sqrt(varu));
 output;
 end;
proc means mean noprint; *take means over 100,000 replications;
 var pld plt pln beta2d beta2t beta2n;
 output out=betas mean=pld plt pln beta2d beta2t beta2n;
run;
data printbetas;
 set betas;
 beta2d=pld+beta2d;
 beta2t=plt+beta2t;
 beta2n=pln+beta2n;
 keep beta2d beta2t beta2n;
proc print data=printbetas;
run;
*Use Monte Carlo integration to compute P(Type I error);
data three;
 set one;
*Compute mean and variance of U_t;
 muu=thetad*(1-tau);
 varu=1-tau;
 *Compute mean and variance of B_t;
 mub=tau*thetai;
 varb=tau;
 do j=1 to 100000;
 b=sqrt(varb)*rannor(85432); *generate from f(b,0) which is N(0,t);
 if b le bld then alpha2d=0;
 else alpha2d=2*(1-probnorm((1.96-b)/sqrt(varu)));
 if b le blt then alpha2t=0;
 else alpha2t=2*(1-probnorm((1.96-b)/sqrt(varu)));
 if b le bln then alpha2n=0;
 else alpha2n=2*(1-probnorm((1.96-b)/sqrt(varu)));
 output;
 end;
proc means mean;
 var alpha2d alpha2t alpha2n;
run;

 
*Prob 7 - Explore the impact of γ on the futility boundary bL at a fixed t,
and the final boundary zF , when we want to preserve α = αD and β − βD × γ at
the conclusion of the trial. Assume αD = 0.05 (two-sided) and θD = 3. Show the
relationship graphically and interpret;
data one;
zf=2;
alpha=1; *initial value for the loop;
beta=0.1; *initial value for the loop;
alphad=0.05;
betad=0.15;
bl=0.5;
power=1-betad;
alphad=0.05;
zd=probit(1-alphad/2);
thetad=probit(power)+probit(1-alphad/2);
tau=0.8;
thetanull=0;
thetaf=3;
thetai=3;
muu=thetaf*(1-tau);
varu=1-tau;
mub=tau*thetai;
varb=tau;
gamma=4/3;
n=100000;
do until (beta>(betad*gamma));  *outer loop over betas;
do until (alpha>alphad);  *inner loop over alphas;
 meanalpha2=0;
 do j=1 to n;
  b1=sqrt(varb)*rannor(85432);
  if b1 le bl then alpha2=0;
  else alpha2=2*(1-probnorm((zf-b1)/sqrt(varu)));
  meanalpha2=meanalpha2+(alpha2/n);
 end;
 alpha=meanalpha2;
 zf=zf-0.01;
 end;
 zf=zf+0.01;
 muu=thetaf*(1-tau);
 varu=1-tau;
 mub=tau*thetai;
 varb=tau;
 beta1=probnorm((bl-tau*thetad)/sqrt(tau));
 meanbeta=0;
 do j=1 to n;
  b=mub+sqrt(varb)*rannor(77653);
  if b le bl then beta2=0;
  else beta2=probnorm((zf-muu-b)/sqrt(varu))-probnorm((-zf-muu-b)/sqrt(varu));
  betasum=beta1+beta2;
  meanbeta=meanbeta+(betasum/n);
 end;
  beta=meanbeta;
  bl=bl+0.01;
 end;
 bl=bl-0.01;
 thetal=bl/tau;  *theta hat;
 pl1=probnorm((thetal-thetai)*sqrt(tau));  *P_LD;
 pl0=probnorm(thetal*sqrt(tau));  *P_LN;
proc print;
 var thetad betad alphad tau gamma thetal pl1 pl0 zf bl alpha beta;
run; 
 
 
*b;
data one;
zf=2;
alpha=1; *initial value for the loop;
beta=0.1; *initial value for the loop;
alphad=0.05;
betad=0.15;
bl=0.5;
power=1-betad;
alphad=0.05;
zd=probit(1-alphad/2);
thetad=probit(power)+probit(1-alphad/2);
tau=0.1;
thetanull=0;
thetaf=3;
thetai=3;
muu=thetaf*(1-tau);
varu=1-tau;
mub=tau*thetai;
varb=tau;
gamma=4/3;
n=100000;
do until (beta>(betad*gamma));  *outer loop over betas;
do until (alpha>alphad);  *inner loop over alphas;
 meanalpha2=0;
 do j=1 to n;
  b1=sqrt(varb)*rannor(85432);
  if b1 le bl then alpha2=0;
  else alpha2=2*(1-probnorm((zf-b1)/sqrt(varu)));
  meanalpha2=meanalpha2+(alpha2/n);
 end;
 alpha=meanalpha2;
 zf=zf-0.01;
 end;
 zf=zf+0.01;
 muu=thetaf*(1-tau);
 varu=1-tau;
 mub=tau*thetai;
 varb=tau;
 beta1=probnorm((bl-tau*thetad)/sqrt(tau));
 meanbeta=0;
 do j=1 to n;
  b=mub+sqrt(varb)*rannor(77653);
  if b le bl then beta2=0;
  else beta2=probnorm((zf-muu-b)/sqrt(varu))-probnorm((-zf-muu-b)/sqrt(varu));
  betasum=beta1+beta2;
  meanbeta=meanbeta+(betasum/n);
 end;
  beta=meanbeta;
  bl=bl+0.01;
 end;
 bl=bl-0.01;
 thetal=bl/tau;  *theta hat;
 pl1=probnorm((thetal-thetai)*sqrt(tau));  *P_LD;
 pl0=probnorm(thetal*sqrt(tau));  *P_LN;
proc print;
 var thetad betad alphad tau gamma thetal pl1 pl0 zf bl alpha beta;
run; 

data one;
zf=2;
alpha=1; *initial value for the loop;
beta=0.1; *initial value for the loop;
alphad=0.05;
betad=0.15;
bl=0.5;
power=1-betad;
alphad=0.05;
zd=probit(1-alphad/2);
thetad=probit(power)+probit(1-alphad/2);
tau=0.2;
thetanull=0;
thetaf=3;
thetai=3;
muu=thetaf*(1-tau);
varu=1-tau;
mub=tau*thetai;
varb=tau;
gamma=4/3;
n=100000;
do until (beta>(betad*gamma));  *outer loop over betas;
do until (alpha>alphad);  *inner loop over alphas;
 meanalpha2=0;
 do j=1 to n;
  b1=sqrt(varb)*rannor(85432);
  if b1 le bl then alpha2=0;
  else alpha2=2*(1-probnorm((zf-b1)/sqrt(varu)));
  meanalpha2=meanalpha2+(alpha2/n);
 end;
 alpha=meanalpha2;
 zf=zf-0.01;
 end;
 zf=zf+0.01;
 muu=thetaf*(1-tau);
 varu=1-tau;
 mub=tau*thetai;
 varb=tau;
 beta1=probnorm((bl-tau*thetad)/sqrt(tau));
 meanbeta=0;
 do j=1 to n;
  b=mub+sqrt(varb)*rannor(77653);
  if b le bl then beta2=0;
  else beta2=probnorm((zf-muu-b)/sqrt(varu))-probnorm((-zf-muu-b)/sqrt(varu));
  betasum=beta1+beta2;
  meanbeta=meanbeta+(betasum/n);
 end;
  beta=meanbeta;
  bl=bl+0.01;
 end;
 bl=bl-0.01;
 thetal=bl/tau;  *theta hat;
 pl1=probnorm((thetal-thetai)*sqrt(tau));  *P_LD;
 pl0=probnorm(thetal*sqrt(tau));  *P_LN;
proc print;
 var thetad betad alphad tau gamma thetal pl1 pl0 zf bl alpha beta;
run; 
 
 data one;
zf=2;
alpha=1; *initial value for the loop;
beta=0.1; *initial value for the loop;
alphad=0.05;
betad=0.15;
bl=0.5;
power=1-betad;
alphad=0.05;
zd=probit(1-alphad/2);
thetad=probit(power)+probit(1-alphad/2);
tau=0.3;
thetanull=0;
thetaf=3;
thetai=3;
muu=thetaf*(1-tau);
varu=1-tau;
mub=tau*thetai;
varb=tau;
gamma=4/3;
n=100000;
do until (beta>(betad*gamma));  *outer loop over betas;
do until (alpha>alphad);  *inner loop over alphas;
 meanalpha2=0;
 do j=1 to n;
  b1=sqrt(varb)*rannor(85432);
  if b1 le bl then alpha2=0;
  else alpha2=2*(1-probnorm((zf-b1)/sqrt(varu)));
  meanalpha2=meanalpha2+(alpha2/n);
 end;
 alpha=meanalpha2;
 zf=zf-0.01;
 end;
 zf=zf+0.01;
 muu=thetaf*(1-tau);
 varu=1-tau;
 mub=tau*thetai;
 varb=tau;
 beta1=probnorm((bl-tau*thetad)/sqrt(tau));
 meanbeta=0;
 do j=1 to n;
  b=mub+sqrt(varb)*rannor(77653);
  if b le bl then beta2=0;
  else beta2=probnorm((zf-muu-b)/sqrt(varu))-probnorm((-zf-muu-b)/sqrt(varu));
  betasum=beta1+beta2;
  meanbeta=meanbeta+(betasum/n);
 end;
  beta=meanbeta;
  bl=bl+0.01;
 end;
 bl=bl-0.01;
 thetal=bl/tau;  *theta hat;
 pl1=probnorm((thetal-thetai)*sqrt(tau));  *P_LD;
 pl0=probnorm(thetal*sqrt(tau));  *P_LN;
proc print;
 var thetad betad alphad tau gamma thetal pl1 pl0 zf bl alpha beta;
run; 
 
 data one;
zf=2;
alpha=1; *initial value for the loop;
beta=0.1; *initial value for the loop;
alphad=0.05;
betad=0.15;
bl=0.5;
power=1-betad;
alphad=0.05;
zd=probit(1-alphad/2);
thetad=probit(power)+probit(1-alphad/2);
tau=0.4;
thetanull=0;
thetaf=3;
thetai=3;
muu=thetaf*(1-tau);
varu=1-tau;
mub=tau*thetai;
varb=tau;
gamma=4/3;
n=100000;
do until (beta>(betad*gamma));  *outer loop over betas;
do until (alpha>alphad);  *inner loop over alphas;
 meanalpha2=0;
 do j=1 to n;
  b1=sqrt(varb)*rannor(85432);
  if b1 le bl then alpha2=0;
  else alpha2=2*(1-probnorm((zf-b1)/sqrt(varu)));
  meanalpha2=meanalpha2+(alpha2/n);
 end;
 alpha=meanalpha2;
 zf=zf-0.01;
 end;
 zf=zf+0.01;
 muu=thetaf*(1-tau);
 varu=1-tau;
 mub=tau*thetai;
 varb=tau;
 beta1=probnorm((bl-tau*thetad)/sqrt(tau));
 meanbeta=0;
 do j=1 to n;
  b=mub+sqrt(varb)*rannor(77653);
  if b le bl then beta2=0;
  else beta2=probnorm((zf-muu-b)/sqrt(varu))-probnorm((-zf-muu-b)/sqrt(varu));
  betasum=beta1+beta2;
  meanbeta=meanbeta+(betasum/n);
 end;
  beta=meanbeta;
  bl=bl+0.01;
 end;
 bl=bl-0.01;
 thetal=bl/tau;  *theta hat;
 pl1=probnorm((thetal-thetai)*sqrt(tau));  *P_LD;
 pl0=probnorm(thetal*sqrt(tau));  *P_LN;
proc print;
 var thetad betad alphad tau gamma thetal pl1 pl0 zf bl alpha beta;
run; 
 
 data one;
zf=2;
alpha=1; *initial value for the loop;
beta=0.1; *initial value for the loop;
alphad=0.05;
betad=0.15;
bl=0.5;
power=1-betad;
alphad=0.05;
zd=probit(1-alphad/2);
thetad=probit(power)+probit(1-alphad/2);
tau=0.5;
thetanull=0;
thetaf=3;
thetai=3;
muu=thetaf*(1-tau);
varu=1-tau;
mub=tau*thetai;
varb=tau;
gamma=4/3;
n=100000;
do until (beta>(betad*gamma));  *outer loop over betas;
do until (alpha>alphad);  *inner loop over alphas;
 meanalpha2=0;
 do j=1 to n;
  b1=sqrt(varb)*rannor(85432);
  if b1 le bl then alpha2=0;
  else alpha2=2*(1-probnorm((zf-b1)/sqrt(varu)));
  meanalpha2=meanalpha2+(alpha2/n);
 end;
 alpha=meanalpha2;
 zf=zf-0.01;
 end;
 zf=zf+0.01;
 muu=thetaf*(1-tau);
 varu=1-tau;
 mub=tau*thetai;
 varb=tau;
 beta1=probnorm((bl-tau*thetad)/sqrt(tau));
 meanbeta=0;
 do j=1 to n;
  b=mub+sqrt(varb)*rannor(77653);
  if b le bl then beta2=0;
  else beta2=probnorm((zf-muu-b)/sqrt(varu))-probnorm((-zf-muu-b)/sqrt(varu));
  betasum=beta1+beta2;
  meanbeta=meanbeta+(betasum/n);
 end;
  beta=meanbeta;
  bl=bl+0.01;
 end;
 bl=bl-0.01;
 thetal=bl/tau;  *theta hat;
 pl1=probnorm((thetal-thetai)*sqrt(tau));  *P_LD;
 pl0=probnorm(thetal*sqrt(tau));  *P_LN;
proc print;
 var thetad betad alphad tau gamma thetal pl1 pl0 zf bl alpha beta;
run; 
 
 data one;
zf=2;
alpha=1; *initial value for the loop;
beta=0.1; *initial value for the loop;
alphad=0.05;
betad=0.15;
bl=0.5;
power=1-betad;
alphad=0.05;
zd=probit(1-alphad/2);
thetad=probit(power)+probit(1-alphad/2);
tau=0.6;
thetanull=0;
thetaf=3;
thetai=3;
muu=thetaf*(1-tau);
varu=1-tau;
mub=tau*thetai;
varb=tau;
gamma=4/3;
n=100000;
do until (beta>(betad*gamma));  *outer loop over betas;
do until (alpha>alphad);  *inner loop over alphas;
 meanalpha2=0;
 do j=1 to n;
  b1=sqrt(varb)*rannor(85432);
  if b1 le bl then alpha2=0;
  else alpha2=2*(1-probnorm((zf-b1)/sqrt(varu)));
  meanalpha2=meanalpha2+(alpha2/n);
 end;
 alpha=meanalpha2;
 zf=zf-0.01;
 end;
 zf=zf+0.01;
 muu=thetaf*(1-tau);
 varu=1-tau;
 mub=tau*thetai;
 varb=tau;
 beta1=probnorm((bl-tau*thetad)/sqrt(tau));
 meanbeta=0;
 do j=1 to n;
  b=mub+sqrt(varb)*rannor(77653);
  if b le bl then beta2=0;
  else beta2=probnorm((zf-muu-b)/sqrt(varu))-probnorm((-zf-muu-b)/sqrt(varu));
  betasum=beta1+beta2;
  meanbeta=meanbeta+(betasum/n);
 end;
  beta=meanbeta;
  bl=bl+0.01;
 end;
 bl=bl-0.01;
 thetal=bl/tau;  *theta hat;
 pl1=probnorm((thetal-thetai)*sqrt(tau));  *P_LD;
 pl0=probnorm(thetal*sqrt(tau));  *P_LN;
proc print;
 var thetad betad alphad tau gamma thetal pl1 pl0 zf bl alpha beta;
run; 
 
 data one;
zf=2;
alpha=1; *initial value for the loop;
beta=0.1; *initial value for the loop;
alphad=0.05;
betad=0.15;
bl=0.5;
power=1-betad;
alphad=0.05;
zd=probit(1-alphad/2);
thetad=probit(power)+probit(1-alphad/2);
tau=0.7;
thetanull=0;
thetaf=3;
thetai=3;
muu=thetaf*(1-tau);
varu=1-tau;
mub=tau*thetai;
varb=tau;
gamma=4/3;
n=100000;
do until (beta>(betad*gamma));  *outer loop over betas;
do until (alpha>alphad);  *inner loop over alphas;
 meanalpha2=0;
 do j=1 to n;
  b1=sqrt(varb)*rannor(85432);
  if b1 le bl then alpha2=0;
  else alpha2=2*(1-probnorm((zf-b1)/sqrt(varu)));
  meanalpha2=meanalpha2+(alpha2/n);
 end;
 alpha=meanalpha2;
 zf=zf-0.01;
 end;
 zf=zf+0.01;
 muu=thetaf*(1-tau);
 varu=1-tau;
 mub=tau*thetai;
 varb=tau;
 beta1=probnorm((bl-tau*thetad)/sqrt(tau));
 meanbeta=0;
 do j=1 to n;
  b=mub+sqrt(varb)*rannor(77653);
  if b le bl then beta2=0;
  else beta2=probnorm((zf-muu-b)/sqrt(varu))-probnorm((-zf-muu-b)/sqrt(varu));
  betasum=beta1+beta2;
  meanbeta=meanbeta+(betasum/n);
 end;
  beta=meanbeta;
  bl=bl+0.01;
 end;
 bl=bl-0.01;
 thetal=bl/tau;  *theta hat;
 pl1=probnorm((thetal-thetai)*sqrt(tau));  *P_LD;
 pl0=probnorm(thetal*sqrt(tau));  *P_LN;
proc print;
 var thetad betad alphad tau gamma thetal pl1 pl0 zf bl alpha beta;
run; 
 
 data one;
zf=2;
alpha=1; *initial value for the loop;
beta=0.1; *initial value for the loop;
alphad=0.05;
betad=0.15;
bl=0.5;
power=1-betad;
alphad=0.05;
zd=probit(1-alphad/2);
thetad=probit(power)+probit(1-alphad/2);
tau=0.8;
thetanull=0;
thetaf=3;
thetai=3;
muu=thetaf*(1-tau);
varu=1-tau;
mub=tau*thetai;
varb=tau;
gamma=4/3;
n=100000;
do until (beta>(betad*gamma));  *outer loop over betas;
do until (alpha>alphad);  *inner loop over alphas;
 meanalpha2=0;
 do j=1 to n;
  b1=sqrt(varb)*rannor(85432);
  if b1 le bl then alpha2=0;
  else alpha2=2*(1-probnorm((zf-b1)/sqrt(varu)));
  meanalpha2=meanalpha2+(alpha2/n);
 end;
 alpha=meanalpha2;
 zf=zf-0.01;
 end;
 zf=zf+0.01;
 muu=thetaf*(1-tau);
 varu=1-tau;
 mub=tau*thetai;
 varb=tau;
 beta1=probnorm((bl-tau*thetad)/sqrt(tau));
 meanbeta=0;
 do j=1 to n;
  b=mub+sqrt(varb)*rannor(77653);
  if b le bl then beta2=0;
  else beta2=probnorm((zf-muu-b)/sqrt(varu))-probnorm((-zf-muu-b)/sqrt(varu));
  betasum=beta1+beta2;
  meanbeta=meanbeta+(betasum/n);
 end;
  beta=meanbeta;
  bl=bl+0.01;
 end;
 bl=bl-0.01;
 thetal=bl/tau;  *theta hat;
 pl1=probnorm((thetal-thetai)*sqrt(tau));  *P_LD;
 pl0=probnorm(thetal*sqrt(tau));  *P_LN;
proc print;
 var thetad betad alphad tau gamma thetal pl1 pl0 zf bl alpha beta;
run; 
 
 
 